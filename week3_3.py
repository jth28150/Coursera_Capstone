# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UfeCBVD2HXEIG7W7CuPk_jnX0ZLO27fH
"""

import urllib.request
import pandas as pd
print('ok')

url = 'https://en.wikipedia.org/wiki/List_of_postal_codes_of_Canada:_M'

page = urllib.request.urlopen(url)

from bs4 import BeautifulSoup

soup = BeautifulSoup(page, "lxml")

soup.title.string

print(soup.prettify())

all_tables=soup.find_all("table")
#all_tables

right_table=soup.find('table', class_='wikitable sortable')
#right_table

A=[]
B=[]
C=[]

for row in right_table.findAll('tr'):
    cells=row.findAll('td')
    if len(cells)==3:
        A.append(cells[0].find(text=True))
        B.append(cells[1].find(text=True))
        C.append(cells[2].find(text=True))

import pandas as pd
df=pd.DataFrame(A,columns=['Postal Code'])
df['Borough']=B
df['Neighborhood']=C

df.head(10)

df = df.replace(r'\n',' ', regex=True)

df.head()

df = df[df.Borough != 'Not assigned ']

df.head()

for index, row in df.iterrows():
  if row['Neighborhood'] == 'Not assigned ':
    row['Neighborhood'] = row['Borough']
#check if the value of column 'Neighborhood' is 'Not assgined '
#if so, replace this value by the value of the column 'Borough'

df.head()

df.reset_index(drop = True)

"""**QUESTION2**"""

data = pd.read_csv('http://cocl.us/Geospatial_data')
#read the csv file which contains the location of each neighborhood

data.tail()
#print the tail of the dataset to check that it had been loaded

df.head()
#check the dataframe, I notice that datas are not sorted in the same way
#Now I have to sort the values to match the location

df.sort_values(by = 'Postal Code', inplace = True)
df.reset_index(drop = True, inplace = True)
df.head()
#I sort the values of my dataframe to match the csv file

data.sort_values(by ='Postal Code', inplace = True)

data.head()
#I also sort the datas of the csv file, to ensure that they will match
#I print both datas to check that they match

df['Latitude'] = data['Latitude']
df['Longitude'] = data['Longitude']
#I add the location of the csv file to my data frame

df.head()
#Print the data frame to check that it had been added

"""**QUESTION3**"""

df_toronto = pd.DataFrame(df[df['Borough'].str.contains("Toronto")])
#df1 is the new dataframe that contains information about bouroughs that contain Toronto
#I will work on this data frame for the question3

df_toronto.reset_index(drop = True, inplace = True)

# Commented out IPython magic to ensure Python compatibility.
import random # library for random number generation
import numpy as np

import matplotlib.pyplot as plt # plotting library
# backend for rendering plots within the browser
# %matplotlib inline 

from sklearn.cluster import KMeans 
from sklearn.datasets.samples_generator import make_blobs

print('Libraries imported.')

from sklearn.preprocessing import StandardScaler

X = df_toronto.values[:,3:]
X = np.nan_to_num(X)
cluster_dataset = StandardScaler().fit_transform(X)
#cluster_dataset

num_clusters = 3

k_means = KMeans(init="k-means++", n_clusters=num_clusters, n_init=12)
k_means.fit(cluster_dataset)
labels = k_means.labels_

print(labels)

df_toronto["Labels"] = labels
df_toronto.head(5)

cluster = df_toronto.groupby('Labels').mean()
#print the mean of each cluster
cluster
#Cluster is my new dataframe which contains the 3 clusster of Toronto boroughs
#they are the mean the boroughs

address = 'Toronto'

geolocator = Nominatim(user_agent="toronto_explorer")
location = geolocator.geocode(address)
latitude = location.latitude
longitude = location.longitude
print('The geograpical coordinate of Toronto are {}, {}.'.format(latitude, longitude))
#Get The location of toronto in order to create a map

# create map of New York using latitude and longitude values
map_toronto = folium.Map(location=[latitude, longitude], zoom_start=12)

#map_toronto
type(df_toronto)

#Creation of the map of toronto, I also added marks that represent each location from the data set df_toronto
marks = folium.map.FeatureGroup()

# loop through the df_toronto and add each to the feature group
for lat, lng, in zip(df_toronto.Latitude, df_toronto.Longitude):
    marks.add_child(
        folium.CircleMarker(
            [lat, lng],
            radius=5, # define how big you want the circle markers to be
            color='yellow',
            fill=True,
            fill_color='blue',
            fill_opacity=0.6
        )
    )

# add marks to map
map_toronto.add_child(marks)

cluster

#Now a create a second map
#This time I add the clusters, in red so I can see where the clusters are compared to other locations from df_toronto
marks1 = folium.map.FeatureGroup()

# loop through the clusters and add each to the feature group 
for lat, lng, in zip(cluster.Latitude, cluster.Longitude):
    marks.add_child(
        folium.CircleMarker(
            [lat, lng],
            radius=5, # define how big you want the circle markers to be
            color='red',
            fill=True,
            fill_color='red',
            fill_opacity=0.6
        )
    )

# add clusters to map
map_toronto.add_child(marks)

